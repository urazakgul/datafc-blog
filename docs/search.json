[
  {
    "objectID": "posts/tr/post5/datafc-v130-yayinda.html",
    "href": "posts/tr/post5/datafc-v130-yayinda.html",
    "title": "datafc v1.3.0 Yayında!",
    "section": "",
    "text": "Neden v1.3.0?\nYeni sürümde past_matches_data fonksiyonu ile iki takımın geçmiş karşılaşmalarını kolayca çekmek mümkün hale geldi.\nYeni sürüme geçmek için aşağıdaki adımları takip edebilirsiniz.\nEğer datafc paketi halihazırda yüklüyse, en son sürüme güncellemek için şu komutu terminalde çalıştırabilirsiniz:\npip install --upgrade datafc\nEğer datafc paketini ilk kez yükleyecekseniz, şu komutu kullanabilirsiniz:\npip install datafc\nPaketle ilgili daha fazla bilgiye ulaşmak için PyPI veya GitHub sayfasını ziyaret edebilirsiniz.\n\n\nYenilikler\nTurnuva, sezon ve haftaya göre oynanacak maçlarda bulunan takım çiftlerinin tüm tarihsel karşılaşmaları çekilebilecek.\n\n\nUygulama\nSüper Lig 2024/25 sezonu 24. haftasındaki takım çiftlerinin tarihsel karşılaşmalarına bakalım.\nfrom datafc.sofascore import past_matches_data\n\npast_matches_df = past_matches_data(\n    tournament_id=52,\n    season_id=63814,\n    week_number=24\n)\n\nSevgiler."
  },
  {
    "objectID": "posts/tr/post3/futbol-maclari-icin-daha-iyi-tahminler-dixon-coles-modeli-nasil-calisir.html",
    "href": "posts/tr/post3/futbol-maclari-icin-daha-iyi-tahminler-dixon-coles-modeli-nasil-calisir.html",
    "title": "Futbol Maçları İçin Daha İyi Tahminler: Dixon-Coles Modeli Nasıl Çalışır?",
    "section": "",
    "text": "Mark J. Dixon ve Stuart G. Coles (1997) tarafından geliştirilen model, geleneksel Poisson regresyonuna bir düzeltme faktörü ekleyerek düşük skorlu maçlardaki bağımlılıkları daha iyi modellemeyi amaçlamaktadır. Bu model, özellikle nadir skorların tahmin doğruluğunu artırarak, bu alanda önemli bir yere sahip olmuştur.\nDixon ve Coles’un Modelling Association Football Scores and Inefficiencies in the Football Betting Market başlıklı çalışması, bu metodolojinin temel taşlarını oluşturur. Model, takımların hücum ve savunma gücünü tahmin etmeye dayanarak, belirli bir maç için olası skor dağılımlarını hesaplamayı hedefler.\n\nBu yazıda, Dixon-Coles modelinin teorik temellerini ayrıntılı bir şekilde inceleyeceğiz. Modelin matematiksel yapısını açıklayarak, parametre tahmin süreçlerine değinecek ve modelin Python ile nasıl uygulanacağını adım adım göreceğiz. Uygulama sürecinde, veri setinin nasıl hazırlanacağı, modelin nasıl optimize edileceği ve sonuçların nasıl yorumlanması gerektiği gibi konulara odaklanacağız.\n\n\nDixon-Coles modeli, futbol maçı sonuçlarının tahmininde Poisson dağılımına dayanan istatistiksel bir yaklaşımdır. Model, her takımın hücum ve savunma yetkinliklerini matematiksel parametreler aracılığıyla temsil eder ve bu parametreleri kullanarak belirli bir maçtaki potansiyel skor dağılımlarını hesaplar. Geleneksel Poisson modelinin aksine, Dixon-Coles modeli düşük skorlu maçlardaki bağımlılıkları daha iyi yakalamak için ek bir düzeltme faktörü içerir. Böylece, modelin tahmin doğruluğu artırılarak daha gerçekçi sonuçlar elde edilmesi sağlanır.\n\n\nPoisson dağılımı, belirli bir zaman aralığında meydana gelen olayların sayısını modellemek için kullanılır ve futbol maçlarında bir takımın attığı gol sayısı için sıkça tercih edilir. Ancak, geleneksel Poisson modeli, takımların gol atma eğilimlerini birbirinden bağımsız olarak ele alır. Dixon ve Coles, düşük skorlu maçlarda bu bağımsızlık varsayımının geçerli olmadığını göstererek modelde bir düzeltme faktörü (\\(\\tau\\)) önermiştir.\nBir takımın gol atma olasılığı şu şekilde ifade edilir:\n\\(P(X=k)=\\frac{e^{-\\lambda}\\lambda^k}{k!}\\)\nBurada:\n\n\\(λ\\): Takımın ortalama gol sayısı\n\\(k\\): Takımın attığı gol sayısı\n\n\n\n\nDixon-Coles modeli, her takımın hücum gücünü (\\(\\alpha\\)) ve savunma gücünü (\\(\\beta\\)) tahmin etmek için geliştirilmiş bir Poisson tabanlı regresyon modelidir. Ek olarak, ev sahibi avantajı (\\(\\gamma\\)) da modele dahil edilir. Modelin özgün katkısı ise takımların gol atma eğilimleri arasındaki bağımlılığı düzeltmek için eklenen \\(\\tau\\) düzeltme faktörüdür. Bu düzeltme faktörü, özellikle düşük skorlu maçları (örn. 0-0, 1-0, 0-1, 1-1) daha iyi modellemeyi amaçlar.\n\n\n\nDixon-Coles modeli, ev sahibi takımın gol sayısı \\(X\\) ve deplasman takımının gol sayısı \\(Y\\) için Poisson dağılımını temel alır. Ancak, geleneksel Poisson modelinden farklı olarak \\(\\tau\\) düzeltme faktörü kullanılır:\n\\(P(X=x, Y=y) = \\tau_{\\lambda,\\mu}(x,y)\\frac{e^{-\\lambda}\\lambda^x}{x!}\\frac{e^{-\\mu}\\mu^y}{y!}\\)\nBurada:\n\n\\(\\lambda\\): Ev sahibi takımın gol beklentisi\n\\(\\mu\\): Deplasman takımının gol beklentisi\n\\(\\tau_{\\lambda,\\mu}(x,y)\\): Düşük skorlu maçlarda bağımlılığı hesaba katan düzeltme faktörü\n\nDixon-Coles, \\(\\tau\\) faktörünün özellikle 0-0, 1-0, 0-1 ve 1-1 skorlarında büyük bir etki yarattığını ve klasik Poisson modeline kıyasla daha iyi sonuçlar verdiğini göstermiştir.\nEv sahibi takımın ortalama gol sayısı \\(\\lambda\\) ve deplasman takımının ortalama gol sayısı \\(\\mu\\), takımların hücum ve savunma güçleri ile ev sahibi avantajı kullanılarak hesaplanır:\n\\(\\lambda = \\alpha_i \\beta_j \\gamma\\)\n\\(\\mu = \\alpha_j \\beta_i\\)\nBurada:\n\n\\(\\alpha_i\\): Ev sahibi takımın hücum gücü\n\\(\\beta_j\\): Deplasman takımının savunma gücü\n\\(\\gamma\\): Ev sahibi avantajı\n\n\n\n\nDixon-Coles modeli, özellikle düşük skorlu maçlarda (0-0, 1-0 gibi) bağımlılığı modellemek için bir düzeltme faktörü kullanır. Bu faktör, maçlar arasındaki bağımlılığı ifade eder ve şu şekilde tanımlanır:\n\\[\n\\tau_{\\lambda, \\mu}(x, y) =\n\\begin{cases}\n1 - \\lambda \\mu \\rho & \\text{if } x = y = 0, \\\\\n1 + \\lambda \\rho & \\text{if } x = 0, y = 1, \\\\\n1 + \\mu \\rho & \\text{if } x = 1, y = 0, \\\\\n1 - \\rho & \\text{if } x = y = 1, \\\\\n1 & \\text{diğer durumlarda}.\n\\end{cases}\n\\]\nBurada \\(\\rho\\), bağımlılık parametresidir."
  },
  {
    "objectID": "posts/tr/post3/futbol-maclari-icin-daha-iyi-tahminler-dixon-coles-modeli-nasil-calisir.html#dixon-coles-modelinin-teorik-temelleri",
    "href": "posts/tr/post3/futbol-maclari-icin-daha-iyi-tahminler-dixon-coles-modeli-nasil-calisir.html#dixon-coles-modelinin-teorik-temelleri",
    "title": "Futbol Maçları İçin Daha İyi Tahminler: Dixon-Coles Modeli Nasıl Çalışır?",
    "section": "",
    "text": "Dixon-Coles modeli, futbol maçı sonuçlarının tahmininde Poisson dağılımına dayanan istatistiksel bir yaklaşımdır. Model, her takımın hücum ve savunma yetkinliklerini matematiksel parametreler aracılığıyla temsil eder ve bu parametreleri kullanarak belirli bir maçtaki potansiyel skor dağılımlarını hesaplar. Geleneksel Poisson modelinin aksine, Dixon-Coles modeli düşük skorlu maçlardaki bağımlılıkları daha iyi yakalamak için ek bir düzeltme faktörü içerir. Böylece, modelin tahmin doğruluğu artırılarak daha gerçekçi sonuçlar elde edilmesi sağlanır.\n\n\nPoisson dağılımı, belirli bir zaman aralığında meydana gelen olayların sayısını modellemek için kullanılır ve futbol maçlarında bir takımın attığı gol sayısı için sıkça tercih edilir. Ancak, geleneksel Poisson modeli, takımların gol atma eğilimlerini birbirinden bağımsız olarak ele alır. Dixon ve Coles, düşük skorlu maçlarda bu bağımsızlık varsayımının geçerli olmadığını göstererek modelde bir düzeltme faktörü (\\(\\tau\\)) önermiştir.\nBir takımın gol atma olasılığı şu şekilde ifade edilir:\n\\(P(X=k)=\\frac{e^{-\\lambda}\\lambda^k}{k!}\\)\nBurada:\n\n\\(λ\\): Takımın ortalama gol sayısı\n\\(k\\): Takımın attığı gol sayısı\n\n\n\n\nDixon-Coles modeli, her takımın hücum gücünü (\\(\\alpha\\)) ve savunma gücünü (\\(\\beta\\)) tahmin etmek için geliştirilmiş bir Poisson tabanlı regresyon modelidir. Ek olarak, ev sahibi avantajı (\\(\\gamma\\)) da modele dahil edilir. Modelin özgün katkısı ise takımların gol atma eğilimleri arasındaki bağımlılığı düzeltmek için eklenen \\(\\tau\\) düzeltme faktörüdür. Bu düzeltme faktörü, özellikle düşük skorlu maçları (örn. 0-0, 1-0, 0-1, 1-1) daha iyi modellemeyi amaçlar.\n\n\n\nDixon-Coles modeli, ev sahibi takımın gol sayısı \\(X\\) ve deplasman takımının gol sayısı \\(Y\\) için Poisson dağılımını temel alır. Ancak, geleneksel Poisson modelinden farklı olarak \\(\\tau\\) düzeltme faktörü kullanılır:\n\\(P(X=x, Y=y) = \\tau_{\\lambda,\\mu}(x,y)\\frac{e^{-\\lambda}\\lambda^x}{x!}\\frac{e^{-\\mu}\\mu^y}{y!}\\)\nBurada:\n\n\\(\\lambda\\): Ev sahibi takımın gol beklentisi\n\\(\\mu\\): Deplasman takımının gol beklentisi\n\\(\\tau_{\\lambda,\\mu}(x,y)\\): Düşük skorlu maçlarda bağımlılığı hesaba katan düzeltme faktörü\n\nDixon-Coles, \\(\\tau\\) faktörünün özellikle 0-0, 1-0, 0-1 ve 1-1 skorlarında büyük bir etki yarattığını ve klasik Poisson modeline kıyasla daha iyi sonuçlar verdiğini göstermiştir.\nEv sahibi takımın ortalama gol sayısı \\(\\lambda\\) ve deplasman takımının ortalama gol sayısı \\(\\mu\\), takımların hücum ve savunma güçleri ile ev sahibi avantajı kullanılarak hesaplanır:\n\\(\\lambda = \\alpha_i \\beta_j \\gamma\\)\n\\(\\mu = \\alpha_j \\beta_i\\)\nBurada:\n\n\\(\\alpha_i\\): Ev sahibi takımın hücum gücü\n\\(\\beta_j\\): Deplasman takımının savunma gücü\n\\(\\gamma\\): Ev sahibi avantajı\n\n\n\n\nDixon-Coles modeli, özellikle düşük skorlu maçlarda (0-0, 1-0 gibi) bağımlılığı modellemek için bir düzeltme faktörü kullanır. Bu faktör, maçlar arasındaki bağımlılığı ifade eder ve şu şekilde tanımlanır:\n\\[\n\\tau_{\\lambda, \\mu}(x, y) =\n\\begin{cases}\n1 - \\lambda \\mu \\rho & \\text{if } x = y = 0, \\\\\n1 + \\lambda \\rho & \\text{if } x = 0, y = 1, \\\\\n1 + \\mu \\rho & \\text{if } x = 1, y = 0, \\\\\n1 - \\rho & \\text{if } x = y = 1, \\\\\n1 & \\text{diğer durumlarda}.\n\\end{cases}\n\\]\nBurada \\(\\rho\\), bağımlılık parametresidir."
  },
  {
    "objectID": "posts/tr/post3/futbol-maclari-icin-daha-iyi-tahminler-dixon-coles-modeli-nasil-calisir.html#sezonu-24.-hafta-tahminleri",
    "href": "posts/tr/post3/futbol-maclari-icin-daha-iyi-tahminler-dixon-coles-modeli-nasil-calisir.html#sezonu-24.-hafta-tahminleri",
    "title": "Futbol Maçları İçin Daha İyi Tahminler: Dixon-Coles Modeli Nasıl Çalışır?",
    "section": "2024/25 Sezonu 24. Hafta Tahminleri",
    "text": "2024/25 Sezonu 24. Hafta Tahminleri\nDixon-Coles modelini Python kullanarak nasıl uygulayabileceğimizi adım adım inceleyelim.\n\nGerekli Kütüphanelerin Yüklenmesi\nÖncelikle, ihtiyacımız olan kütüphaneleri yükleyelim. Bu kütüphaneler, matematiksel hesaplamalar, veri işleme ve optimizasyon işlemleri için kullanılacaktır.\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize, Bounds\nfrom scipy.stats import poisson\n\n\nVeri Setinin Hazırlanması\nModeli uygulamak için veri setinin temelde, ev sahibi ve deplasman takımlarını ve skorlarını içermesi gerekiyor. Hedef veri setine buradan ulaşabilirsiniz.\ndf = pd.read_json(\"./data/tff_super_lig_2425_1-23_maclar.json\", lines=True)\nBu kod, JSON formatındaki veri setini bir pandas DataFrame’ine yükler.\n\n\n\nrho_correction Fonksiyonu\n\\[\n\\tau_{\\lambda, \\mu}(x, y) =\n\\begin{cases}\n1 - \\lambda \\mu \\rho & \\text{if } x = y = 0, \\\\\n1 + \\lambda \\rho & \\text{if } x = 0, y = 1, \\\\\n1 + \\mu \\rho & \\text{if } x = 1, y = 0, \\\\\n1 - \\rho & \\text{if } x = y = 1, \\\\\n1 & \\text{diğer durumlarda}.\n\\end{cases}\n\\]\ndef rho_correction(x, y, lambda_x, mu_y, rho):\n    if x == 0 and y == 0:\n        return max(1 - lambda_x * mu_y * rho, 1e-10)\n    elif x == 0 and y == 1:\n        return 1 + lambda_x * rho\n    elif x == 1 and y == 0:\n        return 1 + mu_y * rho\n    elif x == 1 and y == 1:\n        return max(1 - rho, 1e-10)\n    else:\n        return 1.0\nBu fonksiyon, Dixon-Coles modelinde kullanılan \\(\\tau_{\\lambda,\\mu}(x,y)\\) düzeltme faktörünü hesaplıyor.\n\nPoisson dağılımı bağımsızlık varsayımı yapar ancak Dixon-Coles modelinde düşük skorlu maçlarda bağımlılık olduğu kabul edilir.\n\\(\\rho\\) parametresi bu bağımlılığı hesaba katmak için kullanılır\nmax(1e-10) gibi bir değer hesaplama sırasında sıfıra bölünme hatalarını önlemek için eklendi.\n\n\n\ndc_log_like Fonksiyonu\n\\(logP(X=x, Y=y) = log(\\tau_{\\lambda,\\mu}(x,y))log(\\frac{e^{-\\lambda}\\lambda^x}{x!})log(\\frac{e^{-\\mu}\\mu^y}{y!})\\)\ndef dc_log_like(x, y, alpha_x, beta_x, alpha_y, beta_y, rho, gamma):\n    lambda_x = np.exp(alpha_x + beta_y + gamma)\n    mu_y = np.exp(alpha_y + beta_x)\n    log_lambda_x = np.log(max(poisson.pmf(x, lambda_x), 1e-10))\n    log_mu_y = np.log(max(poisson.pmf(y, mu_y), 1e-10))\n    return (\n        np.log(max(rho_correction(x, y, lambda_x, mu_y, rho), 1e-10)) + log_lambda_x + log_mu_y\n    )\nBu fonksiyon, log-likelihood (olabilirlik) fonksiyonunu hesaplar.\n\n\\(\\lambda_x\\) ve \\(\\mu_y\\), takımların gol beklentilerini ifade eder.\nPoisson olasılıkları hesaplanır ve logaritmaya alınarak çok küçük değerlerin hata üretmesi önlenir ve hesaplamalar sayısal olarak daha stabil hale getirilir.\nDüzeltme faktörü \\(\\tau\\) hesaba katılır, böylece Dixon-Coles modeli klasik Poisson modeline göre daha iyi bir tahmin yapabilir.\n\n\n\nsolve_parameters Fonksiyonu\ndef solve_parameters(dataset, init_vals=None, options={\"disp\": True, \"maxiter\": 100}, **kwargs):\n    teams = np.sort(\n        list(\n            set(dataset[\"home_team\"].unique()) | set(dataset[\"away_team\"].unique())\n        )\n    )\n    n_teams = len(teams)\n\n    if init_vals is None:\n        avg_attack = dataset.groupby(\"home_team\")[\"home_score\"].mean().reindex(teams).fillna(1.0).values\n        avg_defence = -dataset.groupby(\"away_team\")[\"away_score\"].mean().reindex(teams).fillna(1.0).values\n        init_vals = np.concatenate([\n            avg_attack,\n            avg_defence,\n            np.array([0, 1.0])\n        ])\n\n    def estimate_parameters(params):\n        attack_coeffs = dict(zip(teams, params[:n_teams]))\n        defence_coeffs = dict(zip(teams, params[n_teams:2 * n_teams]))\n        rho, gamma = params[-2:]\n\n        log_likelihoods = [\n            dc_log_like(\n                row.home_score,\n                row.away_score,\n                attack_coeffs[row.home_team],\n                defence_coeffs[row.home_team],\n                attack_coeffs[row.away_team],\n                defence_coeffs[row.away_team],\n                rho, gamma\n            )\n            for row in dataset.itertuples()\n        ]\n        return -np.sum(log_likelihoods)\n\n    constraints = [{\"type\": \"eq\", \"fun\": lambda x, n=n_teams: sum(x[:n]) - n}]\n\n    bounds = Bounds(\n        [-np.inf] * n_teams + [-np.inf] * n_teams + [-1, 0],\n        [np.inf] * n_teams + [np.inf] * n_teams + [1, np.inf]\n    )\n\n    opt_output = minimize(estimate_parameters, init_vals, options=options, constraints=constraints, bounds=bounds, **kwargs)\n\n    return dict(\n        zip(\n            [\"attack_\" + team for team in teams] +\n            [\"defence_\" + team for team in teams] +\n            [\"rho\", \"home_adv\"],\n            opt_output.x\n        )\n    )\nBu fonksiyon, Dixon-Coles modelinin parametrelerini tahmin etmek için optimizasyon işlemi yapar.\nÖnce, her takım için saldırı (\\(\\alpha\\)) ve savunma (\\(\\beta\\)) katsayıları, ev sahibi avantajı (\\(\\gamma\\)) ve bağımlılık parametresi (\\(\\rho\\)) optimize edilir.\nOptimizasyon süreci, şu log-likelihood fonksiyonunu maksimize etmek için çalışır:\n\\(\\sum_{i=1}^{N}=logP(X_i=x_i, Y_i=y_i)\\)\n\nTakımların ortalama hücum ve savunma güçleri başlangıç değerleri olarak alınır.\n\\(\\rho\\) ve \\(\\gamma\\) gibi genel katsayılar da optimize edilir.\n\n\n\ndixon_coles_simulate_match Fonksiyonu\ndef dixon_coles_simulate_match(params_dict, home_team, away_team, max_goals=10):\n    def calc_means(param_dict, home_team, away_team):\n        return [\n            np.exp(param_dict[\"attack_\" + home_team] + param_dict[\"defence_\" + away_team] + param_dict[\"home_adv\"]),\n            np.exp(param_dict[\"defence_\" + home_team] + param_dict[\"attack_\" + away_team])\n        ]\n\n    team_avgs = calc_means(params_dict, home_team, away_team)\n    team_pred = [[poisson.pmf(i, team_avg) for i in range(max_goals + 1)] for team_avg in team_avgs]\n\n    output_matrix = np.outer(np.array(team_pred[0]), np.array(team_pred[1]))\n\n    correction_matrix = np.array([\n        [rho_correction(h, a, team_avgs[0], team_avgs[1], params_dict[\"rho\"]) for a in range(2)]\n        for h in range(2)\n    ])\n    output_matrix[:2, :2] *= correction_matrix\n\n    return output_matrix\nBu fonksiyon, belirli bir maçın skor olasılıklarını hesaplar.\nAdımlar:\n\nPoisson dağılımı kullanılarak her takımın belirli sayıda gol atma olasılıkları hesaplanır.\nBu olasılıklar bir matris (çarpım tablosu) şeklinde düzenlenir.\nDixon-Coles düzeltme faktörü (\\(\\tau\\)) eklenerek, düşük skorlu sonuçlar daha iyi modellenir.\n\nMatematiksel olarak:\n\\(P(X=x, Y=y) = \\tau_{\\lambda,\\mu}(x,y)P(X=x)P(Y=y)\\)\nBurada \\(P(X = x)\\) ve \\(P(Y = y)\\), klasik Poisson olasılıklarıdır.\n\n\\(\\tau\\) düzeltmesi sadece (0-0, 1-0, 0-1, 1-1) skorlarına uygulanıyor. Dixon-Coles’un orijinal çalışmasında bu düzeltme yalnızca bu skorlar için önerildiği için bu kısıtlama doğrudur.\n\nYukarıdaki fonksiyonları aşağıdaki gibi özetleyebiliriz.\n\n\n\n\n\n\n\nFonksiyon\nDixon-Coles Modelindeki Karşılığı\n\n\n\n\nrho_correction\n\\(\\tau_{\\lambda, \\mu}(x, y)\\) düzeltme faktörünü hesaplar.\n\n\ndc_log_like\nLog-likelihood fonksiyonunu hesaplar.\n\n\nsolve_parameters\n\\(\\alpha\\), \\(\\beta\\), \\(\\rho\\), \\(\\gamma\\) parametrelerini optimize eder.\n\n\ndixon_coles_simulate_match\nBir maçın skor olasılıklarını hesaplar ve Dixon-Coles düzeltmesini uygular.\n\n\n\n\n\nKodun Çalıştırılması\nparams_dict = solve_parameters(df)\n\n\nParametrelerin Yorumlanması\n\nYukarıdaki değerleri grafik üzerinde görelim.\n\n\nTakımların Hücum Güçleri (attack_*)\nHer takımın hücum gücü (attack), gol atma potansiyelini gösterir.\n\nPozitif değerler: Lig ortalamasının üzerinde hücum gücüne sahip takımlar.\nNegatif değerler: Lig ortalamasının altında hücum gücüne sahip takımlar.\n\n\n\nTakımların Savunma Güçleri (defence_*)\nHer takımın savunma gücü (defence), rakipleri ne kadar durdurabildiğini gösterir.\n\nNegatif değerler: Daha iyi savunma yapan (az gol yiyen) takımlar.\nPozitif değerler: Daha kötü savunma yapan (çok gol yiyen) takımlar.\n\n\n\nEv Sahibi Avantajı (home_adv)\n\nEv sahibi avantajı (home_adv) = 0.2852\nBu değer, ev sahibi takımın gol beklentisini artıran bir faktördür.\nYani, ev sahibi olan bir takımın hücum gücü yaklaşık %28 daha yüksek olarak tahmin edilmektedir.\n\n\n\nBağımlılık Parametresi (\\(\\rho\\))\n\n\\(\\rho\\) değeri = -0.2242\nNegatif \\(\\rho\\) değeri, düşük skorlu maçların beklenenden daha sık olduğunu gösterir.\nÖrneğin, 0-0 ve 1-1 skorları, klasik Poisson modeline göre daha olası.\n\n\n\n\nSonuçların Görselleştirilmesi\nhome_team = \"Adana Demirspor\"\naway_team = \"Antalyaspor\"\nmatch_matrix = dixon_coles_simulate_match(params_dict, home_team, away_team)"
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html",
    "href": "posts/tr/post1/datafc-v100-yayinda.html",
    "title": "datafc v1.0.0 Yayında!",
    "section": "",
    "text": "Futbol analitiği alanındaki çalışmalarımı bir adım ileriye taşımak adına geliştirdiğim datafc paketinin ilk sürümünü geçtiğimiz hafta yayınladım.\nKullanıma başlamak için terminalde aşağıdaki komutu çalıştırabilirsiniz:\npip install datafc\nPaketle ilgili daha fazla bilgiye ulaşmak için PyPI veya GitHub sayfasını ziyaret edebilirsiniz.\nBununla birlikte, datafc çatısı altında ve veri, kod ve futbol üçgeninde içerikler üretmek amacıyla blog sayfası oluşturdum."
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#temel-süreçler",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#temel-süreçler",
    "title": "datafc v1.0.0 Yayında!",
    "section": "Temel Süreçler",
    "text": "Temel Süreçler\n\nVeri Çekme: Futbol verilerinin çeşitli kaynaklardan otomatik olarak toplanmasını kapsar.\nVeri İşleme: Toplanan ham verilerin analize uygun hale getirilmesi için çeşitli işlemler uygulanır.\nVeri Dışa Aktarma: İşlenmiş veriler, kullanıcıların kendi analiz süreçlerinde veya farklı platformlarda kullanabilmesi için çeşitli formatlarda dışa aktarılabilir.\n\nBu üç aşamalı yapı sayesinde datafc, futbol verisiyle çalışan herkes için hızlı, pratik ve güvenilir bir çözüm sunmayı hedefliyor."
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#match_data",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#match_data",
    "title": "datafc v1.0.0 Yayında!",
    "section": "match_data",
    "text": "match_data\nMaçlara ilişkin temel bilgileri içerdiğinden, aşağıdaki altı fonksiyon, veriyi yeniden çekmek yerine mevcut match_data çıktısını kullanır:\n\nmatch_odds_data\nmatch_stats_data\nmomentum_data\nlineups_data\nsubstitutions_data\ngoal_networks_data\nshots_data"
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#lineups_data",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#lineups_data",
    "title": "datafc v1.0.0 Yayında!",
    "section": "lineups_data",
    "text": "lineups_data\nOyuncu kadrolarını içerdiğinden, coordinates_data fonksiyonu doğrudan bu veriyi kullanarak gereksiz veri çekimlerini önler. Ancak, lineups_data fonksiyonunun çalışabilmesi için match_data gereklidir."
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#standings_data",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#standings_data",
    "title": "datafc v1.0.0 Yayında!",
    "section": "standings_data",
    "text": "standings_data\nTamamen bağımsızdır ve herhangi bir veri kaynağına bağımlı olmadan doğrudan çalıştırılabilir.\nBu bağımlılık yönetimi, veri çekme sürecini hızlandırarak gereksiz tekrarları ortadan kaldırmak ve analiz süreçlerini daha verimli hale getirmek için geliştirilmiştir."
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#paketin-içe-aktarılması",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#paketin-içe-aktarılması",
    "title": "datafc v1.0.0 Yayında!",
    "section": "Paketin İçe Aktarılması",
    "text": "Paketin İçe Aktarılması\nfrom datafc.sofascore import (\n    match_data,\n    match_odds_data,\n    match_stats_data,\n    momentum_data,\n    lineups_data,\n    coordinates_data,\n    substitutions_data,\n    goal_networks_data,\n    shots_data,\n    standings_data\n)"
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#match_data-bağımlı-çalışan-fonksiyonlar",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#match_data-bağımlı-çalışan-fonksiyonlar",
    "title": "datafc v1.0.0 Yayında!",
    "section": "match_data Bağımlı Çalışan Fonksiyonlar",
    "text": "match_data Bağımlı Çalışan Fonksiyonlar\nmatch_df = match_data(\n    tournament_id=52,\n    season_id=63814,\n    week_number=22\n)\n\n\nmatch_odds_data\nmatch_odds_df = match_odds_data(\n    match_df=match_df\n)\n\n\n\nmatch_stats_data\nmatch_stats_df = match_stats_data(\n    match_df=match_df\n)\n\n\n\nmomentum_data\nmomentum_df = momentum_data(\n    match_df=match_df\n)\n\n\n\nlineups_data\nlineups_df = lineups_data(\n    match_df=match_df\n)\n\n\n\nsubstitutions_data\nsubstitutions_df = substitutions_data(\n    match_df=match_df\n)\n\n\n\ngoal_networks_data\ngoal_networks_df = goal_networks_data(\n    match_df=match_df\n)\n\n\n\nshots_data\nshots_df = shots_data(\n    match_df=match_df\n)"
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#lineups_data-bağımlı-çalışan-fonksiyonlar",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#lineups_data-bağımlı-çalışan-fonksiyonlar",
    "title": "datafc v1.0.0 Yayında!",
    "section": "lineups_data Bağımlı Çalışan Fonksiyonlar",
    "text": "lineups_data Bağımlı Çalışan Fonksiyonlar\nlineups_data da match_data bağımlı çalıştığı için aslında öncesinde çekmiş olduk.\n\ncoordinates_data\ncoordinates_df = coordinates_data(\n    lineups_df=lineups_df\n)"
  },
  {
    "objectID": "posts/tr/post1/datafc-v100-yayinda.html#bağımlı-çalışmayan-fonksiyon",
    "href": "posts/tr/post1/datafc-v100-yayinda.html#bağımlı-çalışmayan-fonksiyon",
    "title": "datafc v1.0.0 Yayında!",
    "section": "Bağımlı Çalışmayan Fonksiyon",
    "text": "Bağımlı Çalışmayan Fonksiyon\nstandings_data, herhangi bir bağımlılık olmadan çalışmaktadır.\n\nstandings_data\nstandings_df = standings_data(\n    tournament_id=52,\n    season_id=63814\n)"
  },
  {
    "objectID": "posts/en/post5/datafc-v130-is-live.html",
    "href": "posts/en/post5/datafc-v130-is-live.html",
    "title": "datafc v1.3.0 is Live!",
    "section": "",
    "text": "Why v1.3.0?\nThis new version introduces the past_matches_data function, making it easier to fetch past encounters between two teams.\nFollow the steps below to upgrade to the latest version.\nIf the datafc package is already installed, you can update to the latest version by running the following command in the terminal:\npip install --upgrade datafc\nIf you haven’t installed datafc before, use the following command:\npip install datafc\nFor more details about the package, you can visit its PyPI or GitHub pages.\n\n\nNew Features\nYou can now fetch all historical encounters of team pairs in upcoming matches based on tournament, season, and matchweek.\n\n\nPractical Example\nLet’s check the historical encounters of team pairs for matchweek 25 of the 2024/25 Premier League season.\nfrom datafc.sofascore import past_matches_data\n\npast_matches_df = past_matches_data(\n    tournament_id=17,\n    season_id=61627,\n    week_number=25\n)\n\nBest regards."
  },
  {
    "objectID": "posts/en/post3/better-predictions-for-football-matches-how-does-the-dixon-coles-model-work.html",
    "href": "posts/en/post3/better-predictions-for-football-matches-how-does-the-dixon-coles-model-work.html",
    "title": "Better Predictions for Football Matches: How Does the Dixon-Coles Model Work?",
    "section": "",
    "text": "Developed by Mark J. Dixon and Stuart G. Coles in 1997, the Dixon-Coles model improves the modeling of dependencies in low-scoring matches by incorporating a correction factor into the traditional Poisson regression. This model has become significant in the field, particularly for improving the accuracy of predicting rare scores.\nDixon and Coles’ paper, Modelling Association Football Scores and Inefficiencies in the Football Betting Market, serves as the foundation of this methodology. The model estimates teams’ attacking and defensive strengths to calculate the possible score distributions for a given match.\n\nIn this article, we will explore the theoretical foundations of the Dixon-Coles model in detail. We will delve into its mathematical structure, examine the parameter estimation process, and walk through a step-by-step implementation in Python. During the implementation, we will focus on preparing the dataset, optimizing the model, and interpreting the results.\n\n\nThe Dixon-Coles model is a statistical approach that utilizes the Poisson distribution to predict football match outcomes. It quantifies each team’s attacking and defensive strengths using mathematical parameters and applies them to estimate potential score distributions for a given match. Unlike the traditional Poisson model, the Dixon-Coles model includes an additional correction factor to better capture dependencies in low-scoring matches. This adjustment improves the model’s predictive accuracy, leading to more realistic outcomes.\n\n\nThe Poisson distribution is commonly used to model the number of events occurring within a fixed time interval and is frequently applied to predict the number of goals a team scores in football matches. However, the traditional Poisson model assumes that a team’s goal-scoring tendencies are independent of its opponent’s performance. Dixon and Coles showed that this assumption fails in low-scoring matches and introduced a correction factor (\\(\\tau\\)) to adjust the model.\nThe probability of a team scoring a given number of goals is expressed as:\n\\(P(X=k)=\\frac{e^{-\\lambda}\\lambda^k}{k!}\\)\nWhere:\n\n\\(λ\\): The team’s expected number of goals\n\\(k\\): The number of goals scored by the team\n\n\n\n\nThe Dixon-Coles model is a Poisson-based regression model designed to estimate each team’s attacking strength (\\(\\alpha\\)) and defensive capability (\\(\\beta\\)). The model also incorporates home advantage (\\(\\gamma\\)) as an additional factor. Its key innovation is the \\(\\tau\\) correction factor, which accounts for the dependency between teams’ goal-scoring tendencies. This correction factor is particularly useful for improving the modeling of low-scoring matches (e.g., 0-0, 1-0, 0-1, 1-1).\n\n\n\nThe Dixon-Coles model relies on the Poisson distribution to estimate the home team’s goal count \\(X\\) and the away team’s goal count \\(Y\\). However, unlike the traditional Poisson model, it introduces the \\(\\tau\\) correction factor to account for dependencies in low-scoring matches:\n\\(P(X=x, Y=y) = \\tau_{\\lambda,\\mu}(x,y)\\frac{e^{-\\lambda}\\lambda^x}{x!}\\frac{e^{-\\mu}\\mu^y}{y!}\\)\nWhere:\n\n\\(\\lambda\\): Home team’s goal expectation\n\\(\\mu\\): Away team’s goal expectation\n\\(\\tau_{\\lambda,\\mu}(x,y)\\): Correction factor accounting for dependency in low-scoring matches\n\nDixon & Coles demonstrated that the \\(\\tau\\) factor significantly improves accuracy, particularly for 0-0, 1-0, 0-1, and 1-1 scorelines, outperforming the classical Poisson model.\nThe expected goal counts for the home team (\\(\\lambda\\)) and the away team (\\(\\mu\\)) are determined based on the teams’ attacking and defensive strengths, along with the home advantage:\n\\(\\lambda = \\alpha_i \\beta_j \\gamma\\)\n\\(\\mu = \\alpha_j \\beta_i\\)\nWhere:\n\n\\(\\alpha_i\\): Home team’s attacking strength\n\\(\\beta_j\\): Away team’s defensive strength\n\\(\\gamma\\): Home advantage\n\n\n\n\nThe Dixon-Coles model incorporates a correction factor to account for dependencies, particularly in low-scoring matches (e.g., 0-0, 1-0). This factor captures the dependency between goal outcomes and is defined as:\n\\[\n\\tau_{\\lambda, \\mu}(x, y) =\n\\begin{cases}\n1 - \\lambda \\mu \\rho & \\text{if } x = y = 0, \\\\\n1 + \\lambda \\rho & \\text{if } x = 0, y = 1, \\\\\n1 + \\mu \\rho & \\text{if } x = 1, y = 0, \\\\\n1 - \\rho & \\text{if } x = y = 1, \\\\\n1 & \\text{otherwise}.\n\\end{cases}\n\\]\nHere, \\(\\rho\\) represents the dependency parameter."
  },
  {
    "objectID": "posts/en/post3/better-predictions-for-football-matches-how-does-the-dixon-coles-model-work.html#theoretical-foundations-of-the-dixon-coles-model",
    "href": "posts/en/post3/better-predictions-for-football-matches-how-does-the-dixon-coles-model-work.html#theoretical-foundations-of-the-dixon-coles-model",
    "title": "Better Predictions for Football Matches: How Does the Dixon-Coles Model Work?",
    "section": "",
    "text": "The Dixon-Coles model is a statistical approach that utilizes the Poisson distribution to predict football match outcomes. It quantifies each team’s attacking and defensive strengths using mathematical parameters and applies them to estimate potential score distributions for a given match. Unlike the traditional Poisson model, the Dixon-Coles model includes an additional correction factor to better capture dependencies in low-scoring matches. This adjustment improves the model’s predictive accuracy, leading to more realistic outcomes.\n\n\nThe Poisson distribution is commonly used to model the number of events occurring within a fixed time interval and is frequently applied to predict the number of goals a team scores in football matches. However, the traditional Poisson model assumes that a team’s goal-scoring tendencies are independent of its opponent’s performance. Dixon and Coles showed that this assumption fails in low-scoring matches and introduced a correction factor (\\(\\tau\\)) to adjust the model.\nThe probability of a team scoring a given number of goals is expressed as:\n\\(P(X=k)=\\frac{e^{-\\lambda}\\lambda^k}{k!}\\)\nWhere:\n\n\\(λ\\): The team’s expected number of goals\n\\(k\\): The number of goals scored by the team\n\n\n\n\nThe Dixon-Coles model is a Poisson-based regression model designed to estimate each team’s attacking strength (\\(\\alpha\\)) and defensive capability (\\(\\beta\\)). The model also incorporates home advantage (\\(\\gamma\\)) as an additional factor. Its key innovation is the \\(\\tau\\) correction factor, which accounts for the dependency between teams’ goal-scoring tendencies. This correction factor is particularly useful for improving the modeling of low-scoring matches (e.g., 0-0, 1-0, 0-1, 1-1).\n\n\n\nThe Dixon-Coles model relies on the Poisson distribution to estimate the home team’s goal count \\(X\\) and the away team’s goal count \\(Y\\). However, unlike the traditional Poisson model, it introduces the \\(\\tau\\) correction factor to account for dependencies in low-scoring matches:\n\\(P(X=x, Y=y) = \\tau_{\\lambda,\\mu}(x,y)\\frac{e^{-\\lambda}\\lambda^x}{x!}\\frac{e^{-\\mu}\\mu^y}{y!}\\)\nWhere:\n\n\\(\\lambda\\): Home team’s goal expectation\n\\(\\mu\\): Away team’s goal expectation\n\\(\\tau_{\\lambda,\\mu}(x,y)\\): Correction factor accounting for dependency in low-scoring matches\n\nDixon & Coles demonstrated that the \\(\\tau\\) factor significantly improves accuracy, particularly for 0-0, 1-0, 0-1, and 1-1 scorelines, outperforming the classical Poisson model.\nThe expected goal counts for the home team (\\(\\lambda\\)) and the away team (\\(\\mu\\)) are determined based on the teams’ attacking and defensive strengths, along with the home advantage:\n\\(\\lambda = \\alpha_i \\beta_j \\gamma\\)\n\\(\\mu = \\alpha_j \\beta_i\\)\nWhere:\n\n\\(\\alpha_i\\): Home team’s attacking strength\n\\(\\beta_j\\): Away team’s defensive strength\n\\(\\gamma\\): Home advantage\n\n\n\n\nThe Dixon-Coles model incorporates a correction factor to account for dependencies, particularly in low-scoring matches (e.g., 0-0, 1-0). This factor captures the dependency between goal outcomes and is defined as:\n\\[\n\\tau_{\\lambda, \\mu}(x, y) =\n\\begin{cases}\n1 - \\lambda \\mu \\rho & \\text{if } x = y = 0, \\\\\n1 + \\lambda \\rho & \\text{if } x = 0, y = 1, \\\\\n1 + \\mu \\rho & \\text{if } x = 1, y = 0, \\\\\n1 - \\rho & \\text{if } x = y = 1, \\\\\n1 & \\text{otherwise}.\n\\end{cases}\n\\]\nHere, \\(\\rho\\) represents the dependency parameter."
  },
  {
    "objectID": "posts/en/post3/better-predictions-for-football-matches-how-does-the-dixon-coles-model-work.html#season-matchweek-24-predictions",
    "href": "posts/en/post3/better-predictions-for-football-matches-how-does-the-dixon-coles-model-work.html#season-matchweek-24-predictions",
    "title": "Better Predictions for Football Matches: How Does the Dixon-Coles Model Work?",
    "section": "2024/25 Season – Matchweek 24 Predictions",
    "text": "2024/25 Season – Matchweek 24 Predictions\nIn this section, we will implement the Dixon-Coles model step by step using Python.\n\nLoading Required Libraries\nFirst, let’s load the necessary libraries. These libraries are essential for performing mathematical computations, data manipulation, and model optimization.\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize, Bounds\nfrom scipy.stats import poisson\n\n\nPreparing the Dataset\nTo apply the model, the dataset must contain information on home and away teams, along with match scores. You can access the target dataset here.\ndf = pd.read_json(\"./data/tff_super_lig_2425_1-23_matches.json\", lines=True)\nThis code reads the JSON dataset and converts it into a pandas DataFrame for further analysis.\n\n\n\nrho_correction Function\n\\[\n\\tau_{\\lambda, \\mu}(x, y) =\n\\begin{cases}\n1 - \\lambda \\mu \\rho & \\text{if } x = y = 0, \\\\\n1 + \\lambda \\rho & \\text{if } x = 0, y = 1, \\\\\n1 + \\mu \\rho & \\text{if } x = 1, y = 0, \\\\\n1 - \\rho & \\text{if } x = y = 1, \\\\\n1 & \\text{diğer durumlarda}.\n\\end{cases}\n\\]\ndef rho_correction(x, y, lambda_x, mu_y, rho):\n    if x == 0 and y == 0:\n        return max(1 - lambda_x * mu_y * rho, 1e-10)\n    elif x == 0 and y == 1:\n        return 1 + lambda_x * rho\n    elif x == 1 and y == 0:\n        return 1 + mu_y * rho\n    elif x == 1 and y == 1:\n        return max(1 - rho, 1e-10)\n    else:\n        return 1.0\nThis function computes the \\(\\tau_{\\lambda,\\mu}(x,y)\\) correction factor used in the Dixon-Coles model.\n\nThe Poisson distribution assumes independence, whereas the Dixon-Coles model accounts for dependency in low-scoring matches.\nThe \\(\\rho\\) parameter is used to model this dependency.\nA small value like max(1e-10) is included to prevent division-by-zero errors during calculations.\n\n\n\ndc_log_like Function\n\\(logP(X=x, Y=y) = log(\\tau_{\\lambda,\\mu}(x,y))log(\\frac{e^{-\\lambda}\\lambda^x}{x!})log(\\frac{e^{-\\mu}\\mu^y}{y!})\\)\ndef dc_log_like(x, y, alpha_x, beta_x, alpha_y, beta_y, rho, gamma):\n    lambda_x = np.exp(alpha_x + beta_y + gamma)\n    mu_y = np.exp(alpha_y + beta_x)\n    log_lambda_x = np.log(max(poisson.pmf(x, lambda_x), 1e-10))\n    log_mu_y = np.log(max(poisson.pmf(y, mu_y), 1e-10))\n    return (\n        np.log(max(rho_correction(x, y, lambda_x, mu_y, rho), 1e-10)) + log_lambda_x + log_mu_y\n    )\nThis function computes the log-likelihood for the model.\n\n\\(\\lambda_x\\) and \\(\\mu_y\\) denote the expected number of goals for each team.\nPoisson probabilities are computed and log-transformed to prevent numerical errors due to very small values and ensure computational stability.\nThe correction factor \\(\\tau\\) is incorporated, enabling the Dixon-Coles model to outperform the classical Poisson model in predicting match outcomes.\n\n\n\nsolve_parameters Function\ndef solve_parameters(dataset, init_vals=None, options={\"disp\": True, \"maxiter\": 100}, **kwargs):\n    teams = np.sort(\n        list(\n            set(dataset[\"home_team\"].unique()) | set(dataset[\"away_team\"].unique())\n        )\n    )\n    n_teams = len(teams)\n\n    if init_vals is None:\n        avg_attack = dataset.groupby(\"home_team\")[\"home_score\"].mean().reindex(teams).fillna(1.0).values\n        avg_defence = -dataset.groupby(\"away_team\")[\"away_score\"].mean().reindex(teams).fillna(1.0).values\n        init_vals = np.concatenate([\n            avg_attack,\n            avg_defence,\n            np.array([0, 1.0])\n        ])\n\n    def estimate_parameters(params):\n        attack_coeffs = dict(zip(teams, params[:n_teams]))\n        defence_coeffs = dict(zip(teams, params[n_teams:2 * n_teams]))\n        rho, gamma = params[-2:]\n\n        log_likelihoods = [\n            dc_log_like(\n                row.home_score,\n                row.away_score,\n                attack_coeffs[row.home_team],\n                defence_coeffs[row.home_team],\n                attack_coeffs[row.away_team],\n                defence_coeffs[row.away_team],\n                rho, gamma\n            )\n            for row in dataset.itertuples()\n        ]\n        return -np.sum(log_likelihoods)\n\n    constraints = [{\"type\": \"eq\", \"fun\": lambda x, n=n_teams: sum(x[:n]) - n}]\n\n    bounds = Bounds(\n        [-np.inf] * n_teams + [-np.inf] * n_teams + [-1, 0],\n        [np.inf] * n_teams + [np.inf] * n_teams + [1, np.inf]\n    )\n\n    opt_output = minimize(estimate_parameters, init_vals, options=options, constraints=constraints, bounds=bounds, **kwargs)\n\n    return dict(\n        zip(\n            [\"attack_\" + team for team in teams] +\n            [\"defence_\" + team for team in teams] +\n            [\"rho\", \"home_adv\"],\n            opt_output.x\n        )\n    )\nThis function optimizes the parameters of the Dixon-Coles model.\nInitially, the attacking (\\(\\alpha\\)) and defensive (\\(\\beta\\)) coefficients for each team, as well as the home advantage (\\(\\gamma\\)) and dependency parameter (\\(\\rho\\)), are optimized.\nThe optimization process seeks to maximize the following log-likelihood function:\n\\(\\sum_{i=1}^{N}=logP(X_i=x_i, Y_i=y_i)\\)\n\nThe initial values for teams’ attacking and defensive strengths are based on their average performances.\nGlobal parameters such as \\(\\rho\\) and \\(\\gamma\\) are also optimized.\n\n\n\ndixon_coles_simulate_match Function\ndef dixon_coles_simulate_match(params_dict, home_team, away_team, max_goals=10):\n    def calc_means(param_dict, home_team, away_team):\n        return [\n            np.exp(param_dict[\"attack_\" + home_team] + param_dict[\"defence_\" + away_team] + param_dict[\"home_adv\"]),\n            np.exp(param_dict[\"defence_\" + home_team] + param_dict[\"attack_\" + away_team])\n        ]\n\n    team_avgs = calc_means(params_dict, home_team, away_team)\n    team_pred = [[poisson.pmf(i, team_avg) for i in range(max_goals + 1)] for team_avg in team_avgs]\n\n    output_matrix = np.outer(np.array(team_pred[0]), np.array(team_pred[1]))\n\n    correction_matrix = np.array([\n        [rho_correction(h, a, team_avgs[0], team_avgs[1], params_dict[\"rho\"]) for a in range(2)]\n        for h in range(2)\n    ])\n    output_matrix[:2, :2] *= correction_matrix\n\n    return output_matrix\nThis function computes the probability distribution of match scores.\nSteps:\n\nThe Poisson distribution is used to calculate the probability of each team scoring a given number of goals.\nThese probabilities are arranged into a matrix (probability table).\nThe Dixon-Coles correction factor (\\(\\tau\\)) is applied to better model low-scoring outcomes.\n\nMathematically:\n\\(P(X=x, Y=y) = \\tau_{\\lambda,\\mu}(x,y)P(X=x)P(Y=y)\\)\nHere, \\(P(X = x)\\) ve \\(P(Y = y)\\) represent the standard Poisson probabilities.\n\nThe \\(\\tau\\) correction is applied only to (0-0, 1-0, 0-1, 1-1) scorelines, as Dixon and Coles originally proposed this adjustment exclusively for these cases.\n\nWe can summarize the above functions as follows.\n\n\n\n\n\n\n\nFunction\nCorrespondence in the Dixon-Coles Model\n\n\n\n\nrho_correction\nCalculates the \\(\\tau_{\\lambda, \\mu}(x, y)\\) correction factor.\n\n\ndc_log_like\nCalculates the log-likelihood function.\n\n\nsolve_parameters\nOptimizes the \\(\\alpha\\), \\(\\beta\\), \\(\\rho\\), \\(\\gamma\\) parameters.\n\n\ndixon_coles_simulate_match\nCalculates the score probabilities for a match and applies the Dixon-Coles correction.\n\n\n\n\n\nRunning the Code\nparams_dict = solve_parameters(df)\n\n\nInterpreting the Parameters\n\nLet’s visualize the above values on a graph.\n\n\nTeams’ Attacking Strengths (attack_*)\nEach team’s attacking strength (attack) indicates their goal-scoring potential.\n\nPositive values: Teams with above-average attacking strength.\nNegative values: Teams with below-average attacking strength.\n\n\n\nTeams’ Defensive Strengths (defence_*)\nEach team’s defensive strength (defence) indicates how well they can stop opponents.\n\nNegative values: Teams with better defense (conceding fewer goals).\nPositive values: Teams with worse defense (conceding more goals).\n\n\n\nHome Advantage (home_adv)\n\nHome advantage (home_adv) = 0.2852\nThis value is a factor that increases the home team’s goal expectation.\nIn other words, the home team’s attacking strength is estimated to be approximately 28% higher.\n\n\n\nDependency Parameter (\\(\\rho\\))\n\n\\(\\rho\\) value = -0.2242\nA negative \\(\\rho\\) value indicates that low-scoring matches occur more frequently than expected.\nFor example, 0-0 and 1-1 scores are more likely than predicted by the classical Poisson model.\n\n\n\n\nVisualizing the Results\nhome_team = \"Adana Demirspor\"\naway_team = \"Antalyaspor\"\nmatch_matrix = dixon_coles_simulate_match(params_dict, home_team, away_team)"
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html",
    "href": "posts/en/post1/datafc-v100-is-live.html",
    "title": "datafc v1.0.0 is Live!",
    "section": "",
    "text": "I recently released the first version of the datafc package, which I developed to take my work in football analytics one step further.\nTo get started, simply run the following command in your terminal:\npip install datafc\nFor more details about the package, you can visit its PyPI or GitHub pages.\nAdditionally, I have launched a blog under the datafc umbrella to create content at the intersection of data, code, and football."
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#core-processes",
    "href": "posts/en/post1/datafc-v100-is-live.html#core-processes",
    "title": "datafc v1.0.0 is Live!",
    "section": "Core Processes",
    "text": "Core Processes\n\nData Fetching: Automatically fetching football data from various sources.\nData Processing: Transforming raw data into a structured format suitable for analysis.\nData Export: Saving processed data in various formats, allowing users to seamlessly integrate it into their analytics workflows or external platforms.\n\nBy following this three-step framework, datafc aims to provide a fast, efficient, and reliable solution for anyone working with football data."
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#match_data",
    "href": "posts/en/post1/datafc-v100-is-live.html#match_data",
    "title": "datafc v1.0.0 is Live!",
    "section": "match_data",
    "text": "match_data\nSince it contains key information about matches, the following functions use the existing match_data output instead of fetching the data again:\n\nmatch_odds_data\nmatch_stats_data\nmomentum_data\nlineups_data\nsubstitutions_data\ngoal_networks_data\nshots_data"
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#lineups_data",
    "href": "posts/en/post1/datafc-v100-is-live.html#lineups_data",
    "title": "datafc v1.0.0 is Live!",
    "section": "lineups_data",
    "text": "lineups_data\nAs it contains team rosters, the coordinates_data function directly utilizes this data to prevent unnecessary fetching. However, the lineups_data function itself depends on match_data to run."
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#standings_data",
    "href": "posts/en/post1/datafc-v100-is-live.html#standings_data",
    "title": "datafc v1.0.0 is Live!",
    "section": "standings_data",
    "text": "standings_data\nIt is completely independent and can be executed without relying on any other data source.\nThis dependency management optimizes the data-fetching process by eliminating redundant requests and improving the efficiency of analytical workflows."
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#importing-the-package",
    "href": "posts/en/post1/datafc-v100-is-live.html#importing-the-package",
    "title": "datafc v1.0.0 is Live!",
    "section": "Importing the Package",
    "text": "Importing the Package\nfrom datafc.sofascore import (\n    match_data,\n    match_odds_data,\n    match_stats_data,\n    momentum_data,\n    lineups_data,\n    coordinates_data,\n    substitutions_data,\n    goal_networks_data,\n    shots_data,\n    standings_data\n)"
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#functions-dependent-on-match_data",
    "href": "posts/en/post1/datafc-v100-is-live.html#functions-dependent-on-match_data",
    "title": "datafc v1.0.0 is Live!",
    "section": "Functions Dependent on match_data",
    "text": "Functions Dependent on match_data\nmatch_df = match_data(\n    tournament_id=17,\n    season_id=61627,\n    week_number=24\n)\n\n\nmatch_odds_data\nmatch_odds_df = match_odds_data(\n    match_df=match_df\n)\n\n\n\nmatch_stats_data\nmatch_stats_df = match_stats_data(\n    match_df=match_df\n)\n\n\n\nmomentum_data\nmomentum_df = momentum_data(\n    match_df=match_df\n)\n\n\n\nlineups_data\nlineups_df = lineups_data(\n    match_df=match_df\n)\n\n\n\nsubstitutions_data\nsubstitutions_df = substitutions_data(\n    match_df=match_df\n)\n\n\n\ngoal_networks_data\ngoal_networks_df = goal_networks_data(\n    match_df=match_df\n)\n\n\n\nshots_data\nshots_df = shots_data(\n    match_df=match_df\n)"
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#function-dependent-on-lineups_data",
    "href": "posts/en/post1/datafc-v100-is-live.html#function-dependent-on-lineups_data",
    "title": "datafc v1.0.0 is Live!",
    "section": "Function Dependent on lineups_data",
    "text": "Function Dependent on lineups_data\nSince lineups_data also relies on match_data, we’ve already fetched it beforehand.\n\ncoordinates_data\ncoordinates_df = coordinates_data(\n    lineups_df=lineups_df\n)"
  },
  {
    "objectID": "posts/en/post1/datafc-v100-is-live.html#function-without-dependencies",
    "href": "posts/en/post1/datafc-v100-is-live.html#function-without-dependencies",
    "title": "datafc v1.0.0 is Live!",
    "section": "Function Without Dependencies",
    "text": "Function Without Dependencies\nstandings_data operates independently and does not rely on any other function.\n\nstandings_data\nstandings_df = standings_data(\n    tournament_id=17,\n    season_id=61627\n)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "datafc Blog’a Hoş Geldiniz | Welcome to datafc Blog",
    "section": "",
    "text": "datafc_tr_en = {\n    \"Veri\": \"Data\",\n    \"Kod\": \"Code\",\n    \"Futbol\": \"Football\"\n}"
  },
  {
    "objectID": "posts/en/index.html",
    "href": "posts/en/index.html",
    "title": "datafc | English",
    "section": "",
    "text": "English Blog Posts\n\n📄 datafc v1.0.0 is Live!\n📄 datafc v1.1.0 is Live!\n📄 Better Predictions for Football Matches: How Does the Dixon-Coles Model Work?\n📄 datafc v1.2.0 is Live!\n📄 datafc v1.3.0 is Live!"
  },
  {
    "objectID": "posts/en/post2/datafc-v110-is-live.html",
    "href": "posts/en/post2/datafc-v110-is-live.html",
    "title": "datafc v1.1.0 is Live!",
    "section": "",
    "text": "This new version introduces important additions to the match_data dataset.\nFollow the steps below to upgrade to the latest version.\nIf the datafc package is already installed, you can update to the latest version by running the following command in the terminal:\npip install --upgrade datafc\nIf you haven’t installed datafc before, use the following command:\npip install datafc\nFor more details about the package, you can visit its PyPI or GitHub pages."
  },
  {
    "objectID": "posts/en/post2/datafc-v110-is-live.html#team-ids",
    "href": "posts/en/post2/datafc-v110-is-live.html#team-ids",
    "title": "datafc v1.1.0 is Live!",
    "section": "Team IDs",
    "text": "Team IDs\nThe following columns have been added:\n\nhome_team_id: Home team ID\naway_team_id: Away team ID"
  },
  {
    "objectID": "posts/en/post2/datafc-v110-is-live.html#injury-time",
    "href": "posts/en/post2/datafc-v110-is-live.html#injury-time",
    "title": "datafc v1.1.0 is Live!",
    "section": "Injury Time",
    "text": "Injury Time\nThe following columns have been added:\n\ninjury_time_1: First-half injury time\ninjury_time_2: Second-half injury time"
  },
  {
    "objectID": "posts/en/post2/datafc-v110-is-live.html#file-source-information",
    "href": "posts/en/post2/datafc-v110-is-live.html#file-source-information",
    "title": "datafc v1.1.0 is Live!",
    "section": "File Source Information",
    "text": "File Source Information\nThe saved file now includes a prefix indicating the data source."
  },
  {
    "objectID": "posts/en/post4/datafc-v120-is-live.html",
    "href": "posts/en/post4/datafc-v120-is-live.html",
    "title": "datafc v1.2.0 is Live!",
    "section": "",
    "text": "This new version introduces important additions to the match_data dataset related to scores.\nFollow the steps below to upgrade to the latest version.\nIf the datafc package is already installed, you can update to the latest version by running the following command in the terminal:\npip install --upgrade datafc\nIf you haven’t installed datafc before, use the following command:\npip install datafc\nFor more details about the package, you can visit its PyPI or GitHub pages."
  },
  {
    "objectID": "posts/en/post4/datafc-v120-is-live.html#score-information",
    "href": "posts/en/post4/datafc-v120-is-live.html#score-information",
    "title": "datafc v1.2.0 is Live!",
    "section": "Score Information",
    "text": "Score Information\nThe following columns have been added:\n\nhome_score_current: Home team’s most recently recorded score.\nhome_score_display: Home team’s displayed score.\nhome_score_period1: Home team’s goals at the end of the first half.\nhome_score_period2: Home team’s goals in the second half.\nhome_score_normaltime: Home team’s total goals in regular time (90 minutes).\naway_score_current: Away team’s most recently recorded score.\naway_score_display: Away team’s displayed score.\naway_score_period1: Away team’s goals at the end of the first half.\naway_score_period2: Away team’s goals in the second half.\naway_score_normaltime: Away team’s total goals in regular time (90 minutes)."
  },
  {
    "objectID": "posts/tr/index.html",
    "href": "posts/tr/index.html",
    "title": "datafc | Türkçe",
    "section": "",
    "text": "Türkçe Blog Yazıları\n\n📄 datafc v1.0.0 Yayında!\n📄 datafc v1.1.0 Yayında!\n📄 Futbol Maçları İçin Daha İyi Tahminler: Dixon-Coles Modeli Nasıl Çalışır?\n📄 datafc v1.2.0 Yayında!\n📄 datafc v1.3.0 Yayında!"
  },
  {
    "objectID": "posts/tr/post2/datafc-v110-yayinda.html",
    "href": "posts/tr/post2/datafc-v110-yayinda.html",
    "title": "datafc v1.1.0 Yayında!",
    "section": "",
    "text": "Yeni sürümde match_data veri setine önemli eklemeler yapıldı.\nYeni sürüme geçmek için aşağıdaki adımları takip edebilirsiniz.\nEğer datafc paketi halihazırda yüklüyse, en son sürüme güncellemek için şu komutu terminalde çalıştırabilirsiniz:\npip install --upgrade datafc\nEğer datafc paketini ilk kez yükleyecekseniz, şu komutu kullanabilirsiniz:\npip install datafc\nPaketle ilgili daha fazla bilgiye ulaşmak için PyPI veya GitHub sayfasını ziyaret edebilirsiniz."
  },
  {
    "objectID": "posts/tr/post2/datafc-v110-yayinda.html#takım-kimlikleri",
    "href": "posts/tr/post2/datafc-v110-yayinda.html#takım-kimlikleri",
    "title": "datafc v1.1.0 Yayında!",
    "section": "Takım Kimlikleri",
    "text": "Takım Kimlikleri\nAşağıdaki kolonlar eklendi:\n\nhome_team_id: Ev sahibi takımın kimlik numarası\naway_team_id: Deplasman takımının kimlik numarası"
  },
  {
    "objectID": "posts/tr/post2/datafc-v110-yayinda.html#uzatma-süreleri",
    "href": "posts/tr/post2/datafc-v110-yayinda.html#uzatma-süreleri",
    "title": "datafc v1.1.0 Yayında!",
    "section": "Uzatma Süreleri",
    "text": "Uzatma Süreleri\nAşağıdaki kolonlar eklendi:\n\ninjury_time_1: İlk yarının uzatma süresi\ninjury_time_2: İkinci yarının uzatma süresi"
  },
  {
    "objectID": "posts/tr/post2/datafc-v110-yayinda.html#dosya-kaynağı-bilgisi",
    "href": "posts/tr/post2/datafc-v110-yayinda.html#dosya-kaynağı-bilgisi",
    "title": "datafc v1.1.0 Yayında!",
    "section": "Dosya Kaynağı Bilgisi",
    "text": "Dosya Kaynağı Bilgisi\nKayıt edilen dosyanın başına, verinin hangi kaynaktan çekildiğini belirten bir ad eklendi."
  },
  {
    "objectID": "posts/tr/post4/datafc-v120-yayinda.html",
    "href": "posts/tr/post4/datafc-v120-yayinda.html",
    "title": "datafc v1.2.0 Yayında!",
    "section": "",
    "text": "Yeni sürümde match_data veri setine skorlarla ilgili önemli eklemeler yapıldı.\nYeni sürüme geçmek için aşağıdaki adımları takip edebilirsiniz.\nEğer datafc paketi halihazırda yüklüyse, en son sürüme güncellemek için şu komutu terminalde çalıştırabilirsiniz:\npip install --upgrade datafc\nEğer datafc paketini ilk kez yükleyecekseniz, şu komutu kullanabilirsiniz:\npip install datafc\nPaketle ilgili daha fazla bilgiye ulaşmak için PyPI veya GitHub sayfasını ziyaret edebilirsiniz."
  },
  {
    "objectID": "posts/tr/post4/datafc-v120-yayinda.html#skor-bilgileri",
    "href": "posts/tr/post4/datafc-v120-yayinda.html#skor-bilgileri",
    "title": "datafc v1.2.0 Yayında!",
    "section": "Skor Bilgileri",
    "text": "Skor Bilgileri\nAşağıdaki kolonlar eklendi:\n\nhome_score_current: Ev sahibi takımın en son kaydedilen skoru.\nhome_score_display: Ev sahibi takımın ekranda gösterilen skoru.\nhome_score_period1: Ev sahibi takımın ilk yarı sonunda attığı gol sayısı.\nhome_score_period2: Ev sahibi takımın ikinci yarıda attığı gol sayısı.\nhome_score_normaltime: Ev sahibi takımın normal sürede (90 dakika) attığı toplam gol sayısı.\naway_score_current: Deplasman takımının en son kaydedilen skoru.\naway_score_display: Deplasman takımının ekranda gösterilen skoru.\naway_score_period1: Deplasman takımının ilk yarı sonunda attığı gol sayısı.\naway_score_period2: Deplasman takımının ikinci yarıda attığı gol sayısı.\naway_score_normaltime: Deplasman takımının normal sürede (90 dakika) attığı toplam gol sayısı."
  }
]